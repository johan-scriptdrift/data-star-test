
// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
    "fmt"
    "time"
    "zombiezen.com/go/sqlite"
    "github.com/delaneyj/toolbelt"
)

type LocationModel struct {
        Id int64 `json:"id"`
        Lat float64 `json:"lat"`
        Long float64 `json:"long"`
        CreatedAt time.Time `json:"created_at"`
}


type CreateLocationStmt struct {
    stmt *sqlite.Stmt
}

func CreateLocation(tx *sqlite.Conn) *CreateLocationStmt {
    stmt := tx.Prep(`
INSERT INTO locations (
        id,
        lat,
        long,
        created_at
) VALUES (
        ?,
        ?,
        ?,
        ?
)
    `)
    return &CreateLocationStmt{stmt: stmt}
}

func (ps *CreateLocationStmt) Run(m *LocationModel) error {
    defer ps.stmt.Reset()

    // Bind parameters
            ps.            stmt.BindInt64(1, m.Id)

        ps.            stmt.BindFloat(2, m.Lat)

        ps.            stmt.BindFloat(3, m.Long)

        ps.            stmt.BindFloat(4, toolbelt.TimeToJulianDay( m.CreatedAt))



    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to insert locations: %w", err)
    }

    return nil
}

func OnceCreateLocation(tx *sqlite.Conn, m *LocationModel) error {
    ps := CreateLocation(tx)
    return ps.Run(m)
}

type ReadAllLocationsStmt struct {
    stmt *sqlite.Stmt
}

func ReadAllLocations(tx *sqlite.Conn) *ReadAllLocationsStmt {
    stmt := tx.Prep(`
SELECT
        id,
        lat,
        long,
        created_at
FROM locations
    `)
    return &ReadAllLocationsStmt{stmt: stmt}
}

func (ps *ReadAllLocationsStmt) Run() ([]LocationModel, error) {
    defer ps.stmt.Reset()

    var models []LocationModel
    for {
        hasRow, err := ps.stmt.Step()
        if err != nil {
            return nil, fmt.Errorf("failed to read locations: %w", err)
        } else if !hasRow {
            break
        }

        m := LocationModel{}
        
    m.Id =             ps.stmt.ColumnInt64(0)

    m.Lat =             ps.stmt.ColumnFloat(1)

    m.Long =             ps.stmt.ColumnFloat(2)

    m.CreatedAt =             toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(3))



        models = append(models, m)
    }

    return models, nil
}

func OnceReadAllLocations(tx *sqlite.Conn) ([]LocationModel, error) {
    ps := ReadAllLocations(tx)
    return ps.Run()
}

type ReadByIDLocationStmt struct {
    stmt *sqlite.Stmt
}

func ReadByIDLocation(tx *sqlite.Conn) *ReadByIDLocationStmt {
    stmt := tx.Prep(`
SELECT
        id,
        lat,
        long,
        created_at
FROM locations
WHERE id = ?
    `)
    return &ReadByIDLocationStmt{stmt: stmt}
}

func (ps *ReadByIDLocationStmt) Run(id int64) (*LocationModel, error) {
    defer ps.stmt.Reset()

    ps.stmt.BindInt64(1, id)

    if hasRow, err := ps.stmt.Step(); err != nil {
        return nil, fmt.Errorf("failed to read locations: %w", err)
    } else if !hasRow {
        return nil, nil
    }

    m := &LocationModel{}
    
    m.Id =             ps.stmt.ColumnInt64(0)

    m.Lat =             ps.stmt.ColumnFloat(1)

    m.Long =             ps.stmt.ColumnFloat(2)

    m.CreatedAt =             toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(3))



    return m, nil
}

func OnceReadByIDLocation(tx *sqlite.Conn, id int64) (*LocationModel, error) {
    ps := ReadByIDLocation(tx)
    return ps.Run(id)
}

func CountLocations(tx *sqlite.Conn) (int64, error) {
    stmt := tx.Prep(`
SELECT COUNT(*)
FROM locations
    `)
    defer stmt.Reset()

    if hasRow, err := stmt.Step(); err != nil {
        return 0, fmt.Errorf("failed to count locations: %w", err)
    } else if !hasRow {
        return 0, nil
    }

    return stmt.ColumnInt64(0), nil
}

func OnceCountLocations(tx *sqlite.Conn) (int64, error) {
    return CountLocations(tx)
}

type UpdateLocationStmt struct {
    stmt *sqlite.Stmt
}

func UpdateLocation(tx *sqlite.Conn) *UpdateLocationStmt {
    stmt := tx.Prep(`
UPDATE locations
SET
        lat = ?2,
        long = ?3,
        created_at = ?4
WHERE id = ?1
    `)
    return &UpdateLocationStmt{stmt: stmt}
}

func (ps *UpdateLocationStmt) Run(m *LocationModel) error {
    defer ps.stmt.Reset()

    // Bind parameters
            ps.            stmt.BindInt64(1, m.Id)

        ps.            stmt.BindFloat(2, m.Lat)

        ps.            stmt.BindFloat(3, m.Long)

        ps.            stmt.BindFloat(4, toolbelt.TimeToJulianDay( m.CreatedAt))



    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to update locations: %w", err)
    }

    return nil
}

func OnceUpdateLocation(tx *sqlite.Conn, m *LocationModel) error {
    ps := UpdateLocation(tx)
    return ps.Run(m)
}

type DeleteLocationStmt struct {
    stmt *sqlite.Stmt
}

func DeleteLocation(tx *sqlite.Conn) *DeleteLocationStmt {
    stmt := tx.Prep(`
DELETE FROM locations
WHERE id = ?
    `)
    return &DeleteLocationStmt{stmt: stmt}
}

func (ps *DeleteLocationStmt) Run(id int64) error {
    defer ps.stmt.Reset()

    ps.stmt.BindInt64(1, id)

    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to delete locations: %w", err)
    }

    return nil
}

func OnceDeleteLocation(tx *sqlite.Conn, id int64) error {
    ps := DeleteLocation(tx)
    return ps.Run(id)
}

