
// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
    "fmt"
    "time"
    "zombiezen.com/go/sqlite"
    "github.com/delaneyj/toolbelt"
)

type UserModel struct {
        Id int64 `json:"id"`
        FirstName string `json:"first_name"`
        LastName string `json:"last_name"`
        Email string `json:"email"`
        PasswordHash []byte `json:"password_hash"`
        CreatedAt time.Time `json:"created_at"`
}


type CreateUserStmt struct {
    stmt *sqlite.Stmt
}

func CreateUser(tx *sqlite.Conn) *CreateUserStmt {
    stmt := tx.Prep(`
INSERT INTO users (
        id,
        first_name,
        last_name,
        email,
        password_hash,
        created_at
) VALUES (
        ?,
        ?,
        ?,
        ?,
        ?,
        ?
)
    `)
    return &CreateUserStmt{stmt: stmt}
}

func (ps *CreateUserStmt) Run(m *UserModel) error {
    defer ps.stmt.Reset()

    // Bind parameters
            ps.            stmt.BindInt64(1, m.Id)

        ps.            stmt.BindText(2, m.FirstName)

        ps.            stmt.BindText(3, m.LastName)

        ps.            stmt.BindText(4, m.Email)

        ps.            stmt.BindBytes(5, m.PasswordHash)

        ps.            stmt.BindFloat(6, toolbelt.TimeToJulianDay( m.CreatedAt))



    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to insert users: %w", err)
    }

    return nil
}

func OnceCreateUser(tx *sqlite.Conn, m *UserModel) error {
    ps := CreateUser(tx)
    return ps.Run(m)
}

type ReadAllUsersStmt struct {
    stmt *sqlite.Stmt
}

func ReadAllUsers(tx *sqlite.Conn) *ReadAllUsersStmt {
    stmt := tx.Prep(`
SELECT
        id,
        first_name,
        last_name,
        email,
        password_hash,
        created_at
FROM users
    `)
    return &ReadAllUsersStmt{stmt: stmt}
}

func (ps *ReadAllUsersStmt) Run() ([]*UserModel, error) {
    defer ps.stmt.Reset()

    var models []*UserModel
    for {
        hasRow, err := ps.stmt.Step()
        if err != nil {
            return nil, fmt.Errorf("failed to read users: %w", err)
        } else if !hasRow {
            break
        }

        m := &UserModel{}
        
    m.Id =             ps.stmt.ColumnInt64(0)

    m.FirstName =             ps.stmt.ColumnText(1)

    m.LastName =             ps.stmt.ColumnText(2)

    m.Email =             ps.stmt.ColumnText(3)

    m.PasswordHash =             toolbelt.StmtBytesByCol(ps.stmt, 4)

    m.CreatedAt =             toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(5))



        models = append(models, m)
    }

    return models, nil
}

func OnceReadAllUsers(tx *sqlite.Conn) ([]*UserModel, error) {
    ps := ReadAllUsers(tx)
    return ps.Run()
}

type ReadByIDUserStmt struct {
    stmt *sqlite.Stmt
}

func ReadByIDUser(tx *sqlite.Conn) *ReadByIDUserStmt {
    stmt := tx.Prep(`
SELECT
        id,
        first_name,
        last_name,
        email,
        password_hash,
        created_at
FROM users
WHERE id = ?
    `)
    return &ReadByIDUserStmt{stmt: stmt}
}

func (ps *ReadByIDUserStmt) Run(id int64) (*UserModel, error) {
    defer ps.stmt.Reset()

    ps.stmt.BindInt64(1, id)

    if hasRow, err := ps.stmt.Step(); err != nil {
        return nil, fmt.Errorf("failed to read users: %w", err)
    } else if !hasRow {
        return nil, nil
    }

    m := &UserModel{}
    
    m.Id =             ps.stmt.ColumnInt64(0)

    m.FirstName =             ps.stmt.ColumnText(1)

    m.LastName =             ps.stmt.ColumnText(2)

    m.Email =             ps.stmt.ColumnText(3)

    m.PasswordHash =             toolbelt.StmtBytesByCol(ps.stmt, 4)

    m.CreatedAt =             toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(5))



    return m, nil
}

func OnceReadByIDUser(tx *sqlite.Conn, id int64) (*UserModel, error) {
    ps := ReadByIDUser(tx)
    return ps.Run(id)
}

func CountUsers(tx *sqlite.Conn) (int64, error) {
    stmt := tx.Prep(`
SELECT COUNT(*)
FROM users
    `)
    defer stmt.Reset()

    if hasRow, err := stmt.Step(); err != nil {
        return 0, fmt.Errorf("failed to count users: %w", err)
    } else if !hasRow {
        return 0, nil
    }

    return stmt.ColumnInt64(0), nil
}

func OnceCountUsers(tx *sqlite.Conn) (int64, error) {
    return CountUsers(tx)
}

type UpdateUserStmt struct {
    stmt *sqlite.Stmt
}

func UpdateUser(tx *sqlite.Conn) *UpdateUserStmt {
    stmt := tx.Prep(`
UPDATE users
SET
        first_name = ?2,
        last_name = ?3,
        email = ?4,
        password_hash = ?5,
        created_at = ?6
WHERE id = ?1
    `)
    return &UpdateUserStmt{stmt: stmt}
}

func (ps *UpdateUserStmt) Run(m *UserModel) error {
    defer ps.stmt.Reset()

    // Bind parameters
            ps.            stmt.BindInt64(1, m.Id)

        ps.            stmt.BindText(2, m.FirstName)

        ps.            stmt.BindText(3, m.LastName)

        ps.            stmt.BindText(4, m.Email)

        ps.            stmt.BindBytes(5, m.PasswordHash)

        ps.            stmt.BindFloat(6, toolbelt.TimeToJulianDay( m.CreatedAt))



    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to update users: %w", err)
    }

    return nil
}

func OnceUpdateUser(tx *sqlite.Conn, m *UserModel) error {
    ps := UpdateUser(tx)
    return ps.Run(m)
}

type DeleteUserStmt struct {
    stmt *sqlite.Stmt
}

func DeleteUser(tx *sqlite.Conn) *DeleteUserStmt {
    stmt := tx.Prep(`
DELETE FROM users
WHERE id = ?
    `)
    return &DeleteUserStmt{stmt: stmt}
}

func (ps *DeleteUserStmt) Run(id int64) error {
    defer ps.stmt.Reset()

    ps.stmt.BindInt64(1, id)

    if _, err := ps.stmt.Step(); err != nil {
        return fmt.Errorf("failed to delete users: %w", err)
    }

    return nil
}

func OnceDeleteUser(tx *sqlite.Conn, id int64) error {
    ps := DeleteUser(tx)
    return ps.Run(id)
}

