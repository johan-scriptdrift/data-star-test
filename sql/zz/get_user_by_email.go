
// Code generated by "sqlc-gen-zombiezen". DO NOT EDIT.

package zz

import (
    "fmt"
    "zombiezen.com/go/sqlite"

    
    "time"
    "github.com/delaneyj/toolbelt"
    
)


type GetUserByEmailRes struct {
        Id int64 `json:"id"`
        FirstName string `json:"first_name"`
        LastName string `json:"last_name"`
        Email string `json:"email"`
        PasswordHash []byte `json:"password_hash"`
        CreatedAt time.Time `json:"created_at"`
}




type GetUserByEmailStmt struct {
    stmt *sqlite.Stmt
}

func GetUserByEmail(tx *sqlite.Conn) *GetUserByEmailStmt {
    // Prepare the statement into connection cache
    stmt := tx.Prep(`
SELECT
    id, first_name, last_name, email, password_hash, created_at
FROM
    users
WHERE
    email = ?1
    `)
    ps := &GetUserByEmailStmt{stmt: stmt}
    return ps
}

func (ps *GetUserByEmailStmt) Run(
            email  string,
) (
            res *GetUserByEmailRes,
    err error,
) {
    defer ps.stmt.Reset()

    // Bind parameters
                    ps.stmt.BindText(1, email)

    // Execute the query
        if hasRow, err := ps.stmt.Step(); err != nil {
            return res, fmt.Errorf("failed to execute {{.Name.Lower}} SQL: %w", err)
        } else if hasRow {
                row := GetUserByEmailRes{}
            row.Id =         ps.stmt.ColumnInt64(0)
            row.FirstName =         ps.stmt.ColumnText(1)
            row.LastName =         ps.stmt.ColumnText(2)
            row.Email =         ps.stmt.ColumnText(3)
            row.PasswordHash =         toolbelt.StmtBytesByCol(ps.stmt, 4)
            row.CreatedAt =         toolbelt.JulianDayToTime(ps.stmt.ColumnFloat(5))
            res = &row
        }

    return res, nil
}

func OnceGetUserByEmail(
    tx *sqlite.Conn,
            email  string,
) (
            res *GetUserByEmailRes,
    err error,
) {
    ps := GetUserByEmail(tx)

    return ps.Run(
                    email,

    )
}

